# å®‰å…¨å’Œæ€§èƒ½è§„èŒƒ (Security & Performance Rules)

## ğŸ›¡ï¸ **å®‰å…¨è§„èŒƒå’Œæœ€ä½³å®è·µï¼ˆæ–°å¢ï¼‰**

### **ğŸ” è®¤è¯å’Œæˆæƒå®‰å…¨**
```typescript
// âœ… JWTä»¤ç‰Œå®‰å…¨å¤„ç†
const authService = {
  // å®‰å…¨çš„ä»¤ç‰Œå­˜å‚¨ï¼ˆä»…httpOnly cookieï¼‰
  setTokens: (accessToken: string, refreshToken: string) => {
    // è®¿é—®ä»¤ç‰Œå­˜å‚¨åœ¨å†…å­˜ä¸­ï¼ˆæ›´å®‰å…¨ï¼‰
    sessionStorage.setItem('access_token', accessToken)
    // åˆ·æ–°ä»¤ç‰Œä½¿ç”¨httpOnly cookieï¼ˆé˜²XSSï¼‰
    document.cookie = `refresh_token=${refreshToken}; httpOnly; secure; sameSite=strict`
  },
  
  // ä»¤ç‰ŒéªŒè¯å’Œåˆ·æ–°
  validateAndRefreshToken: async () => {
    try {
      const token = sessionStorage.getItem('access_token')
      if (!token) throw new Error('No token')
      
      // éªŒè¯ä»¤ç‰Œæœ‰æ•ˆæ€§
      const decoded = jwt.decode(token)
      if (decoded.exp * 1000 < Date.now()) {
        return await refreshAccessToken()
      }
      return token
    } catch (error) {
      redirectToLogin()
    }
  }
}

// âŒ å±é™©çš„åšæ³•
localStorage.setItem('jwt_token', token)  // å®¹æ˜“è¢«XSSæ”»å‡»
const token = 'hardcoded-token'          // ç¡¬ç¼–ç æ•æ„Ÿä¿¡æ¯
```

### **ğŸ›¡ï¸ è¾“å…¥éªŒè¯å’Œæ•°æ®æ¸…ç†**
```typescript
// âœ… å‰ç«¯è¾“å…¥éªŒè¯ï¼ˆZodï¼‰
import { z } from 'zod'

const registrationSchema = z.object({
  email: z.string().email('è¯·è¾“å…¥æœ‰æ•ˆçš„é‚®ç®±åœ°å€'),
  password: z.string()
    .min(8, 'å¯†ç è‡³å°‘8ä½')
    .regex(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/, 
           'å¯†ç å¿…é¡»åŒ…å«å¤§å°å†™å­—æ¯ã€æ•°å­—å’Œç‰¹æ®Šå­—ç¬¦'),
  username: z.string()
    .min(3, 'ç”¨æˆ·åè‡³å°‘3ä½')
    .max(20, 'ç”¨æˆ·åæœ€å¤š20ä½')
    .regex(/^[a-zA-Z0-9_-]+$/, 'ç”¨æˆ·ååªèƒ½åŒ…å«å­—æ¯ã€æ•°å­—ã€ä¸‹åˆ’çº¿å’ŒçŸ­æ¨ªçº¿')
})

// âœ… åç«¯æ•°æ®æ¸…ç†ï¼ˆStrapiï¼‰
import validator from 'validator'
import xss from 'xss'

export default factories.createCoreController('api::article.article', ({ strapi }) => ({
  async create(ctx) {
    const { data } = ctx.request.body
    
    // è¾“å…¥éªŒè¯å’Œæ¸…ç†
    const cleanData = {
      title: xss(validator.escape(data.title)),
      content: xss(data.content, {
        whiteList: {
          p: [], strong: [], em: [], u: [], 
          h1: [], h2: [], h3: [], 
          ul: [], ol: [], li: [],
          a: ['href', 'title'], img: ['src', 'alt']
        }
      }),
      slug: validator.isSlug(data.slug) ? data.slug : null
    }
    
    return await strapi.entityService.create('api::article.article', {
      data: cleanData
    })
  }
}))
```

### **ğŸ”’ HTTPSå’Œå®‰å…¨å¤´é…ç½®**
```typescript
// âœ… Next.js å®‰å…¨å¤´é…ç½®
const nextConfig = {
  async headers() {
    return [
      {
        source: '/(.*)',
        headers: [
          {
            key: 'X-Content-Type-Options',
            value: 'nosniff'
          },
          {
            key: 'X-Frame-Options',
            value: 'DENY'
          },
          {
            key: 'X-XSS-Protection',
            value: '1; mode=block'
          },
          {
            key: 'Strict-Transport-Security',
            value: 'max-age=31536000; includeSubDomains'
          },
          {
            key: 'Content-Security-Policy',
            value: "default-src 'self'; script-src 'self' 'unsafe-eval'; style-src 'self' 'unsafe-inline'"
          }
        ]
      }
    ]
  }
}
```

### **ğŸ“§ é‚®ä»¶å®‰å…¨è§„èŒƒ**
```typescript
// âœ… é‚®ä»¶å‘é€å®‰å…¨æ£€æŸ¥
const emailSecurityService = {
  // é‚®ç®±æ ¼å¼éªŒè¯
  validateEmail: (email: string): boolean => {
    return validator.isEmail(email) && !validator.isIn(email, blacklistedDomains)
  },
  
  // å‘é€é¢‘ç‡é™åˆ¶
  checkRateLimit: async (email: string, type: 'verification' | 'marketing'): Promise<boolean> => {
    const key = `email_rate_${type}_${email}`
    const count = await redis.get(key) || 0
    
    const limits = {
      verification: 3,  // éªŒè¯é‚®ä»¶ï¼šæ¯å°æ—¶æœ€å¤š3å°
      marketing: 1      // è¥é”€é‚®ä»¶ï¼šæ¯å¤©æœ€å¤š1å°
    }
    
    if (count >= limits[type]) {
      throw new Error('å‘é€é¢‘ç‡è¶…é™ï¼Œè¯·ç¨åå†è¯•')
    }
    
    await redis.setex(key, type === 'verification' ? 3600 : 86400, count + 1)
    return true
  },
  
  // é‚®ä»¶å†…å®¹å®‰å…¨æ£€æŸ¥
  sanitizeEmailContent: (content: string): string => {
    return xss(content, {
      whiteList: {
        p: [], strong: [], em: [], br: [],
        a: ['href', 'style'], 
        img: ['src', 'alt', 'style'],
        div: ['style'], span: ['style']
      },
      stripIgnoreTag: true,
      stripIgnoreTagBody: ['script', 'style']
    })
  }
}
```

## âš¡ **æ€§èƒ½ä¼˜åŒ–è§„èŒƒï¼ˆæ–°å¢ï¼‰**

### **ğŸš€ å‰ç«¯æ€§èƒ½ä¼˜åŒ–æ ‡å‡†**
```typescript
// âœ… ç»„ä»¶æ‡’åŠ è½½å’Œä»£ç åˆ†å‰²
import { lazy, Suspense } from 'react'
import dynamic from 'next/dynamic'

// è·¯ç”±çº§åˆ«çš„æ‡’åŠ è½½
const ArticleDetail = lazy(() => import('@/components/organisms/ArticleDetail'))

// Next.js åŠ¨æ€å¯¼å…¥ï¼ˆSSRå‹å¥½ï¼‰
const SearchModal = dynamic(() => import('@/components/molecules/SearchModal'), {
  ssr: false,
  loading: () => <div>Loading...</div>
})

// âœ… å›¾ç‰‡ä¼˜åŒ–
import Image from 'next/image'

const ArticleCard = ({ article }) => (
  <div className="article-card">
    <Image
      src={article.featuredImage}
      alt={article.title}
      width={400}
      height={300}
      priority={article.featured} // é‡è¦å›¾ç‰‡ä¼˜å…ˆåŠ è½½
      placeholder="blur"
      blurDataURL="data:image/jpeg;base64,..." // å ä½ç¬¦
      sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
    />
  </div>
)

// âœ… æ•°æ®è·å–ä¼˜åŒ–
import { useQuery, useInfiniteQuery } from '@tanstack/react-query'

export const useArticles = (filters: ArticleFilters) => {
  return useQuery({
    queryKey: ['articles', filters],
    queryFn: () => strapiClient.getArticles(filters),
    staleTime: 5 * 60 * 1000, // 5åˆ†é’Ÿç¼“å­˜
    gcTime: 10 * 60 * 1000,   // 10åˆ†é’Ÿåƒåœ¾å›æ”¶
    retry: 3,
    retryDelay: attemptIndex => Math.min(1000 * 2 ** attemptIndex, 30000)
  })
}

// âœ… è™šæ‹Ÿæ»šåŠ¨ï¼ˆå¤§é‡æ•°æ®ï¼‰
import { FixedSizeList as List } from 'react-window'

const ArticleVirtualList = ({ articles }) => (
  <List
    height={600}
    itemCount={articles.length}
    itemSize={120}
    itemData={articles}
  >
    {({ index, style, data }) => (
      <div style={style}>
        <ArticleCard article={data[index]} />
      </div>
    )}
  </List>
)
```

### **ğŸ—„ï¸ åç«¯æ€§èƒ½ä¼˜åŒ–æ ‡å‡†**
```typescript
// âœ… æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–
export default factories.createCoreController('api::article.article', ({ strapi }) => ({
  async find(ctx) {
    const { page = 1, pageSize = 25 } = ctx.query
    
    // ç²¾ç¡®æŒ‡å®šéœ€è¦çš„å­—æ®µï¼Œé¿å…over-fetching
    const populate = {
      author: {
        fields: ['name', 'avatar']
      },
      category: {
        fields: ['name', 'slug', 'color']
      },
      tags: {
        fields: ['name', 'color']
      },
      featuredImage: {
        fields: ['url', 'alternativeText', 'width', 'height']
      }
    }
    
    // ä½¿ç”¨ç´¢å¼•ä¼˜åŒ–çš„æŸ¥è¯¢
    const result = await strapi.entityService.findMany('api::article.article', {
      fields: ['title', 'slug', 'excerpt', 'publishedAt', 'viewCount'],
      populate,
      pagination: { page, pageSize },
      sort: { publishedAt: 'desc' },
      // ç¼“å­˜æŸ¥è¯¢ç»“æœ
      cache: {
        key: `articles_${page}_${pageSize}`,
        ttl: 5 * 60 * 1000 // 5åˆ†é’Ÿ
      }
    })
    
    return result
  },
  
  // âœ… æ‰¹é‡æ“ä½œä¼˜åŒ–
  async updateViewCount(ctx) {
    const { id } = ctx.params
    
    // ä½¿ç”¨åŸç”ŸSQLè¿›è¡Œé«˜æ•ˆæ›´æ–°
    await strapi.db.query('api::article.article').update({
      where: { id },
      data: {
        viewCount: strapi.db.connection.raw('view_count + 1')
      }
    })
    
    return { success: true }
  }
}))

// âœ… ç¼“å­˜ç­–ç•¥
import NodeCache from 'node-cache'

const cache = new NodeCache({
  stdTTL: 300,      // 5åˆ†é’Ÿé»˜è®¤TTL
  checkperiod: 60,  // æ¯åˆ†é’Ÿæ£€æŸ¥è¿‡æœŸ
  useClones: false  // æ€§èƒ½ä¼˜åŒ–
})

export const cacheMiddleware = async (ctx, next) => {
  const cacheKey = `${ctx.method}:${ctx.url}`
  
  if (ctx.method === 'GET') {
    const cached = cache.get(cacheKey)
    if (cached) {
      ctx.body = cached
      return
    }
  }
  
  await next()
  
  if (ctx.method === 'GET' && ctx.status === 200) {
    cache.set(cacheKey, ctx.body)
  }
}
```

### **ğŸ“Š æœç´¢æ€§èƒ½ä¼˜åŒ–**
```typescript
// âœ… MeiliSearchä¼˜åŒ–é…ç½®
export const optimizeMeiliSearch = async () => {
  const client = new MeiliSearch({ host: config.search.url })
  
  // é…ç½®æœç´¢è®¾ç½®
  await client.index('articles').updateSettings({
    // æœç´¢å­—æ®µæƒé‡
    searchableAttributes: [
      'title',      // æƒé‡æœ€é«˜
      'content',    // æƒé‡ä¸­ç­‰
      'excerpt',    // æƒé‡è¾ƒä½
      'tags.name'   // æƒé‡æœ€ä½
    ],
    
    // æ˜¾ç¤ºå­—æ®µ
    displayedAttributes: [
      'id', 'title', 'excerpt', 'slug', 'publishedAt',
      'author.name', 'category.name', 'tags.name'
    ],
    
    // è¿‡æ»¤å­—æ®µ
    filterableAttributes: [
      'category.slug', 'tags.name', 'author.slug', 
      'featured', 'publishedAt'
    ],
    
    // æ’åºå­—æ®µ
    sortableAttributes: [
      'publishedAt', 'viewCount', 'title'
    ],
    
    // ä¸­æ–‡åˆ†è¯ä¼˜åŒ–
    stopWords: ['çš„', 'æ˜¯', 'åœ¨', 'æœ‰', 'å’Œ', 'å°±', 'ä¸', 'äº†', 'ä»¥'],
    synonyms: {
      'AI': ['äººå·¥æ™ºèƒ½', 'æœºå™¨å­¦ä¹ '],
      'å˜ç°': ['èµšé’±', 'ç›ˆåˆ©', 'æ”¶ç›Š']
    }
  })
}
```

### **âš¡ æ€§èƒ½æ£€æŸ¥å¼ºåˆ¶æ¸…å•**
```bash
# ğŸ”¥ æ¯æ¬¡å¼€å‘å®Œæˆåå¿…é¡»æ‰§è¡Œçš„æ€§èƒ½æ£€æŸ¥

# âœ… ç¬¬1æ­¥ï¼šå‰ç«¯æ€§èƒ½æ£€æŸ¥
echo "æ£€æŸ¥å‰ç«¯Bundleå¤§å°..."
cd frontend && npm run build 2>&1 | grep -E "(First Load JS|Route.*chunks)"

echo "æ£€æŸ¥å›¾ç‰‡ä¼˜åŒ–..."
find public/images -type f \( -name "*.jpg" -o -name "*.png" \) -size +500k -exec echo "âš ï¸ å›¾ç‰‡è¿‡å¤§: {}" \;

echo "æ£€æŸ¥CSSå˜é‡ä½¿ç”¨..."
grep -r "color: #" src/styles/ && echo "âŒ å‘ç°ç¡¬ç¼–ç é¢œè‰²" || echo "âœ… CSSå˜é‡ä½¿ç”¨æ­£ç¡®"

# âœ… ç¬¬2æ­¥ï¼šAPIæ€§èƒ½æ£€æŸ¥
echo "æ£€æŸ¥APIå“åº”æ—¶é—´..."
time curl -s "http://localhost:1337/api/articles?pagination[pageSize]=25" > /dev/null

echo "æ£€æŸ¥æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–..."
cd backend && grep -r "findMany" src/ | wc -l | xargs echo "æ•°æ®åº“æŸ¥è¯¢æ•°é‡:"

# âœ… ç¬¬3æ­¥ï¼šå†…å­˜ä½¿ç”¨æ£€æŸ¥
echo "æ£€æŸ¥Node.jså†…å­˜ä½¿ç”¨..."
ps aux | grep node | grep -v grep | awk '{print $4"%", $11}' | head -5

# âœ… ç¬¬4æ­¥ï¼šç½‘ç»œè¯·æ±‚æ£€æŸ¥
echo "æ£€æŸ¥æ˜¯å¦æœ‰å¤šä½™çš„APIè°ƒç”¨..."
grep -r "fetch\|axios\|useQuery" frontend/src/ | wc -l | xargs echo "APIè°ƒç”¨æ€»æ•°:"

# ğŸ”¥ æ€§èƒ½é˜ˆå€¼æ ‡å‡†
# - Bundleå¤§å° < 500KB (First Load JS)
# - APIå“åº”æ—¶é—´ < 500ms
# - å›¾ç‰‡å¤§å° < 500KB
# - å†…å­˜ä½¿ç”¨ < 20%
```

## ğŸ“Š **ç›‘æ§å’Œæ—¥å¿—è§„èŒƒï¼ˆæ–°å¢ï¼‰**

### **ğŸ” ç³»ç»Ÿç›‘æ§æ ‡å‡†**
```typescript
// âœ… å¥åº·æ£€æŸ¥ç«¯ç‚¹
export const healthCheck = {
  // åº”ç”¨å¥åº·çŠ¶æ€
  async checkApplication(): Promise<HealthStatus> {
    return {
      status: 'healthy',
      timestamp: new Date().toISOString(),
      uptime: process.uptime(),
      memory: process.memoryUsage(),
      version: process.env.npm_package_version
    }
  },
  
  // æ•°æ®åº“è¿æ¥æ£€æŸ¥
  async checkDatabase(): Promise<HealthStatus> {
    try {
      await strapi.db.connection.raw('SELECT 1')
      return { status: 'healthy', service: 'database' }
    } catch (error) {
      return { status: 'unhealthy', service: 'database', error: error.message }
    }
  },
  
  // å¤–éƒ¨æœåŠ¡æ£€æŸ¥
  async checkExternalServices(): Promise<HealthStatus[]> {
    const services = [
      { name: 'meilisearch', url: `${config.search.url}/health` },
      { name: 'smtp', check: () => testSMTPConnection() }
    ]
    
    return Promise.all(services.map(async service => {
      try {
        if (service.url) {
          const response = await fetch(service.url, { timeout: 5000 })
          return { 
            service: service.name, 
            status: response.ok ? 'healthy' : 'unhealthy' 
          }
        } else {
          await service.check()
          return { service: service.name, status: 'healthy' }
        }
      } catch (error) {
        return { 
          service: service.name, 
          status: 'unhealthy', 
          error: error.message 
        }
      }
    }))
  }
}
```

### **ğŸ“ æ—¥å¿—ç®¡ç†æ ‡å‡†**
```typescript
// âœ… ç»“æ„åŒ–æ—¥å¿—ç³»ç»Ÿ
import winston from 'winston'

export const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  defaultMeta: {
    service: 'aibianx-backend',
    version: process.env.npm_package_version
  },
  transports: [
    // æ§åˆ¶å°è¾“å‡º
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.colorize(),
        winston.format.simple()
      )
    }),
    
    // æ–‡ä»¶æ—¥å¿—
    new winston.transports.File({
      filename: 'logs/error.log',
      level: 'error',
      maxsize: 10485760, // 10MB
      maxFiles: 5
    }),
    new winston.transports.File({
      filename: 'logs/combined.log',
      maxsize: 10485760,
      maxFiles: 10
    })
  ]
})

// âœ… APIè¯·æ±‚æ—¥å¿—ä¸­é—´ä»¶
export const requestLogger = (ctx, next) => {
  const start = Date.now()
  
  logger.info('Request started', {
    method: ctx.method,
    url: ctx.url,
    userAgent: ctx.get('User-Agent'),
    ip: ctx.ip,
    requestId: ctx.state.requestId
  })
  
  return next().then(() => {
    const duration = Date.now() - start
    
    logger.info('Request completed', {
      method: ctx.method,
      url: ctx.url,
      status: ctx.status,
      duration,
      requestId: ctx.state.requestId
    })
  }).catch(error => {
    const duration = Date.now() - start
    
    logger.error('Request failed', {
      method: ctx.method,
      url: ctx.url,
      error: error.message,
      stack: error.stack,
      duration,
      requestId: ctx.state.requestId
    })
    
    throw error
  })
}
```

### **ğŸš¨ é”™è¯¯ç›‘æ§å’Œå‘Šè­¦**
```typescript
// âœ… é”™è¯¯æ•è·å’ŒæŠ¥å‘Š
export const errorHandler = async (ctx, next) => {
  try {
    await next()
  } catch (error) {
    // è®°å½•é”™è¯¯è¯¦æƒ…
    logger.error('Application error', {
      error: error.message,
      stack: error.stack,
      method: ctx.method,
      url: ctx.url,
      body: ctx.request.body,
      query: ctx.query,
      headers: ctx.headers,
      requestId: ctx.state.requestId
    })
    
    // å‘é€å‘Šè­¦ï¼ˆç”Ÿäº§ç¯å¢ƒï¼‰
    if (process.env.NODE_ENV === 'production') {
      await sendAlert({
        type: 'application_error',
        severity: error.status >= 500 ? 'high' : 'medium',
        message: error.message,
        context: {
          service: 'aibianx-backend',
          endpoint: `${ctx.method} ${ctx.url}`,
          timestamp: new Date().toISOString()
        }
      })
    }
    
    // è¿”å›æ ‡å‡†é”™è¯¯å“åº”
    ctx.status = error.status || 500
    ctx.body = {
      error: {
        status: ctx.status,
        name: error.name || 'InternalServerError',
        message: process.env.NODE_ENV === 'production' 
          ? 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯' 
          : error.message
      }
    }
  }
}
```

## ğŸ“ˆ **ä»£ç è´¨é‡è§„èŒƒï¼ˆæ–°å¢ï¼‰**

### **ğŸ”§ TypeScripté…ç½®æ ‡å‡†**
```json
// âœ… ä¸¥æ ¼çš„tsconfig.jsoné…ç½®
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "noImplicitReturns": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "exactOptionalPropertyTypes": true,
    "noImplicitOverride": true,
    "noPropertyAccessFromIndexSignature": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", ".tmp"]
}
```

### **ğŸ“ ESLintå’ŒPrettieré…ç½®**
```javascript
// âœ… .eslintrc.js æ ‡å‡†é…ç½®
module.exports = {
  extends: [
    'next/core-web-vitals',
    '@typescript-eslint/recommended',
    'prettier'
  ],
  rules: {
    '@typescript-eslint/no-unused-vars': 'error',
    '@typescript-eslint/explicit-function-return-type': 'warn',
    'react-hooks/exhaustive-deps': 'error',
    'prefer-const': 'error',
    'no-var': 'error'
  }
}
```

### **ğŸ“‹ å®‰å…¨å’Œæ€§èƒ½æ£€æŸ¥æ¸…å•**
- [ ] è¾“å…¥éªŒè¯å’Œæ•°æ®æ¸…ç†å®ç°
- [ ] JWTä»¤ç‰Œå®‰å…¨å¤„ç†
- [ ] HTTPSå’Œå®‰å…¨å¤´é…ç½®
- [ ] APIé€Ÿç‡é™åˆ¶è®¾ç½®
- [ ] æ•æ„Ÿä¿¡æ¯é˜²æ³„éœ²
- [ ] XSSå’ŒCSRFé˜²æŠ¤
- [ ] æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–
- [ ] ç¼“å­˜ç­–ç•¥å®ç°
- [ ] å›¾ç‰‡å’Œèµ„æºä¼˜åŒ–
- [ ] Bundleå¤§å°æ§åˆ¶
- [ ] è™šæ‹Ÿæ»šåŠ¨å®ç°ï¼ˆå¤§æ•°æ®é‡ï¼‰
- [ ] æ‡’åŠ è½½å’Œä»£ç åˆ†å‰²
- [ ] æ€§èƒ½ç›‘æ§è®¾ç½®
- [ ] é”™è¯¯ç›‘æ§å’Œå‘Šè­¦
- [ ] æ—¥å¿—ç³»ç»Ÿå®Œå–„