# 硬编码预防和语法规范 - AI变现之路项目专用规则

## 🚨 核心原则
**绝对禁止任何形式的硬编码！** 这是不可违背的铁律，任何硬编码都会导致系统维护困难、环境切换问题和代码质量下降。

---

## 🚫 硬编码禁止清单

### 1. **URL和域名硬编码 (最高优先级)**

#### ❌ **严禁使用的硬编码模式**
```bash
# 绝对禁止
export FRONTEND_URL="http://localhost"
export BACKEND_URL="http://localhost:1337" 
curl -s "http://localhost:1337/api/articles"
if curl -s "http://localhost" > /dev/null 2>&1; then

# 绝对禁止
echo "访问地址: http://localhost:1337/admin"
open "http://localhost:8000"
```

#### ✅ **正确的动态配置方式**
```bash
# 1. 从配置文件读取
frontend_domain=$(grep "NEXT_PUBLIC_FRONTEND_DOMAIN=" "$CONFIG_FILE" | cut -d'=' -f2 | tr -d '"' || echo "localhost")
frontend_port=$(grep "NEXT_PUBLIC_FRONTEND_PORT=" "$CONFIG_FILE" | cut -d'=' -f2 | tr -d '"' || echo "80")
frontend_protocol=$(grep "NEXT_PUBLIC_FRONTEND_PROTOCOL=" "$CONFIG_FILE" | cut -d'=' -f2 | tr -d '"' || echo "http")

# 2. 智能URL构建
if ([ "$frontend_port" = "80" ] && [ "$frontend_protocol" = "http" ]) || ([ "$frontend_port" = "443" ] && [ "$frontend_protocol" = "https" ]); then
    export FRONTEND_URL="${frontend_protocol}://${frontend_domain}"
else
    export FRONTEND_URL="${frontend_protocol}://${frontend_domain}:${frontend_port}"
fi

# 3. 使用动态变量
curl -s "${BACKEND_API_URL}/articles"
if curl -s "${FRONTEND_URL}" > /dev/null 2>&1; then
echo "访问地址: ${BACKEND_ADMIN_URL}"
```

### 2. **端口硬编码**

#### ❌ **严禁使用**
```bash
check_port 1337 "strapi"
check_port 80 "next"
lsof -i :1337
netstat -tuln | grep ":5432 "
```

#### ✅ **正确方式**
```bash
check_port "$BACKEND_PORT" "strapi"
check_port "$FRONTEND_PORT" "next"
lsof -i :"$DATABASE_PORT"
netstat -tuln | grep ":$DATABASE_PORT "
```

### 3. **路径硬编码**

#### ❌ **严禁使用**
```bash
cd /Volumes/wwx/dev/WebProjects/aibianx
source /path/to/script.sh
cp file.txt /usr/local/bin/
```

#### ✅ **正确方式**
```bash
cd "$PROJECT_ROOT" || cd "$(dirname "$0")"
source "$(dirname "$0")/script.sh"
cp file.txt "$INSTALL_DIR/"
```

### 4. **颜色硬编码**

#### ❌ **严禁使用**
```bash
echo -e "\033[0;32m✅ 成功\033[0m"
echo -e "\033[0;31m❌ 失败\033[0m"
```

#### ✅ **正确方式**
```bash
# 在配置文件中定义
export GREEN='\033[0;32m'
export RED='\033[0;31m'
export NC='\033[0m'

# 使用变量
echo -e "${GREEN}✅ 成功${NC}"
echo -e "${RED}❌ 失败${NC}"
```

### 5. **数据库配置硬编码**

#### ❌ **严禁使用**
```bash
psql -U postgres -d myapp -h localhost -p 5432
DATABASE_URL="postgresql://user:pass@localhost:5432/db"
```

#### ✅ **正确方式**
```bash
psql -U "$DATABASE_USERNAME" -d "$DATABASE_NAME" -h "$DATABASE_HOST" -p "$DATABASE_PORT"
DATABASE_URL="postgresql://$DATABASE_USERNAME:$DATABASE_PASSWORD@$DATABASE_HOST:$DATABASE_PORT/$DATABASE_NAME"
```

---

## 🔧 语法问题避免规范

### 1. **Bash条件判断语法**

#### ❌ **常见错误**
```bash
# 错误的逻辑运算符组合
if [ "$port" = "80" ] && [ "$protocol" = "http" ] || [ "$port" = "443" ] && [ "$protocol" = "https" ]; then

# 缺少括号的复杂条件
if [ -f file1 ] && [ -f file2 ] || [ -f file3 ]; then
```

#### ✅ **正确语法**
```bash
# 使用括号明确逻辑优先级
if ([ "$port" = "80" ] && [ "$protocol" = "http" ]) || ([ "$port" = "443" ] && [ "$protocol" = "https" ]); then

# 复杂条件分组
if ([ -f file1 ] && [ -f file2 ]) || [ -f file3 ]; then
```

### 2. **变量引用规范**

#### ❌ **常见错误**
```bash
# 未引用变量（容易出现空格问题）
if [ $PORT = 80 ]; then
cp $FILE $DEST

# 部分引用
if [ "$PORT" = 80 ]; then  # 缺少对80的引用
```

#### ✅ **正确方式**
```bash
# 完全引用
if [ "$PORT" = "80" ]; then
cp "$FILE" "$DEST"

# 数组和特殊情况
for item in "${ARRAY[@]}"; do
```

### 3. **函数调用和返回值**

#### ❌ **常见错误**
```bash
# 不检查函数返回值
load_config
start_service

# 错误的错误处理
command || echo "失败"  # 没有实际处理
```

#### ✅ **正确方式**
```bash
# 检查返回值
if ! load_config; then
    echo "❌ 配置加载失败"
    exit 1
fi

# 适当的错误处理
if ! start_service; then
    echo "❌ 服务启动失败"
    cleanup_resources
    exit 1
fi
```

### 4. **TypeScript类型问题**

#### ❌ **常见错误**
```typescript
// 硬编码类型断言
const config = data as any;
// 忽略类型错误
// @ts-ignore
const result = someFunction();
```

#### ✅ **正确方式**
```typescript
// 合适的类型定义
interface Config {
    domain: string;
    port: number;
    protocol: 'http' | 'https';
}

// 类型安全的断言
const config = data as Config;
// 或者类型守卫
function isConfig(obj: any): obj is Config {
    return obj && typeof obj.domain === 'string';
}
```

---

## 📋 强制检查清单

### **代码写入前必须检查**
- [ ] **URL检查**: 任何URL都使用动态变量，无硬编码
- [ ] **端口检查**: 所有端口使用配置变量
- [ ] **路径检查**: 所有路径使用相对路径或配置变量
- [ ] **颜色检查**: 颜色代码使用预定义变量
- [ ] **语法检查**: 复杂条件正确使用括号
- [ ] **变量引用**: 所有变量正确引用和检查返回值

### **具体检查命令**
```bash
# 1. 检查硬编码URL
grep -r "http://localhost" scripts/ || echo "✅ 无硬编码URL"
grep -r "https://localhost" scripts/ || echo "✅ 无硬编码HTTPS"

# 2. 检查硬编码端口
grep -r ":1337" scripts/ | grep -v "\$" || echo "✅ 无硬编码端口"
grep -r ":5432" scripts/ | grep -v "\$" || echo "✅ 无硬编码数据库端口"

# 3. 检查硬编码颜色
grep -r "\\033\[" scripts/ | grep -v "\$" || echo "✅ 无硬编码颜色"

# 4. 语法检查
bash -n script.sh || echo "❌ 语法错误"
```

---

## 🛠️ 最佳实践模板

### 1. **动态配置加载模板**
```bash
# 通用配置加载函数
load_service_config() {
    local service_name="$1"
    local config_file="$2"
    
    # 读取配置
    local domain=$(grep "${service_name}_DOMAIN=" "$config_file" | cut -d'=' -f2 | tr -d '"' || echo "localhost")
    local port=$(grep "${service_name}_PORT=" "$config_file" | cut -d'=' -f2 | tr -d '"' || echo "80")
    local protocol=$(grep "${service_name}_PROTOCOL=" "$config_file" | cut -d'=' -f2 | tr -d '"' || echo "http")
    
    # 构建URL
    if ([ "$port" = "80" ] && [ "$protocol" = "http" ]) || ([ "$port" = "443" ] && [ "$protocol" = "https" ]); then
        export "${service_name}_URL=${protocol}://${domain}"
    else
        export "${service_name}_URL=${protocol}://${domain}:${port}"
    fi
}
```

### 2. **健康检查模板**
```bash
# 通用服务健康检查
check_service_health() {
    local service_name="$1"
    local url_var="${service_name}_URL"
    local health_endpoint="$2"
    
    # 动态获取URL
    local service_url="${!url_var}"
    
    if curl -s "${service_url}${health_endpoint}" > /dev/null 2>&1; then
        echo -e "${GREEN}✅ ${service_name} 服务正常 (${service_url})${NC}"
        return 0
    else
        echo -e "${RED}❌ ${service_name} 服务异常${NC}"
        return 1
    fi
}
```

### 3. **配置文件生成模板**
```bash
# 动态配置生成
generate_service_config() {
    local service="$1"
    local domain="$2"
    local port="$3"
    local protocol="$4"
    
    cat >> "$CONFIG_FILE" << EOF
# ${service} 服务配置
${service}_DOMAIN=${domain}
${service}_PORT=${port}
${service}_PROTOCOL=${protocol}
EOF
}
```

---

## 🚨 错误案例分析

### **案例1：URL硬编码错误**
```bash
# ❌ 错误代码
if curl -s "http://localhost:1337/api/articles" > /dev/null 2>&1; then
    echo -e "✅ 后端API正常 (http://localhost:1337)"
fi

# ✅ 修复后
if curl -s "${BACKEND_API_URL}/articles" > /dev/null 2>&1; then
    echo -e "${GREEN}✅ 后端API正常 (${BACKEND_API_URL})${NC}"
fi
```

**问题分析**：
- 硬编码导致无法适配不同环境
- 端口变更需要多处修改
- 违反项目规范

### **案例2：条件判断语法错误**
```bash
# ❌ 错误代码
if [ "$port" = "80" ] && [ "$protocol" = "http" ] || [ "$port" = "443" ] && [ "$protocol" = "https" ]; then

# ✅ 修复后
if ([ "$port" = "80" ] && [ "$protocol" = "http" ]) || ([ "$port" = "443" ] && [ "$protocol" = "https" ]); then
```

**问题分析**：
- 逻辑运算符优先级不明确
- 可能导致意外的条件判断结果
- 难以理解和维护

---

## 🎯 实施建议

### 1. **立即实施**
- 所有新代码必须遵循此规范
- 现有代码逐步重构
- 建立代码审查机制

### 2. **工具辅助**
```bash
# 创建检查脚本
#!/bin/bash
echo "🔍 硬编码检查..."
scripts/tools/check-hardcode.sh

echo "🔍 语法检查..."
find scripts/ -name "*.sh" -exec bash -n {} \;
```

### 3. **团队培训**
- 定期分享最佳实践
- 重点强调硬编码危害
- 建立规范意识

### 4. **持续改进**
- 收集新的错误模式
- 及时更新规范文件
- 建立知识积累机制

---

## 🔄 强制工作流程

### **开发前必须执行的检查清单**

#### 1. **硬编码检查（每次代码变更前）**
```bash
# 🚨 任何代码修改前必须执行
./scripts/tools/check-hardcode.sh

# 返回码处理：
# 0 = 无问题，可以继续开发  
# 1 = 严重问题，必须立即修复
# 2 = 警告问题，建议修复
```

#### 2. **文件行数检查（代码写入前）**
```bash
# 检查目标文件行数
wc -l target_file.sh
# 如果接近500行，必须先执行文件分离
```

#### 3. **动态配置验证**
```bash
# 确保环境配置正确加载
source scripts/tools/load-config.sh
echo "✅ FRONTEND_URL: $FRONTEND_URL"
echo "✅ BACKEND_API_URL: $BACKEND_API_URL"
```

### **提交前强制检查**

#### 1. **完整硬编码扫描**
```bash
# 全面扫描，确保无遗漏
./scripts/tools/check-hardcode.sh
if [ $? -ne 0 ]; then
    echo "❌ 发现硬编码问题，禁止提交"
    exit 1
fi
```

#### 2. **语法检查**
```bash
# 检查所有Shell脚本语法
find scripts/ -name "*.sh" -exec bash -n {} \;
```

#### 3. **服务启动测试**
```bash
# 验证修改后系统能正常启动
./scripts.sh deploy stop
./scripts.sh deploy start
```

### **新建内容类型后的验证**
```bash
# 动态URL验证（替代硬编码）
content_type="新建的内容类型名"
echo "🔍 验证Admin界面访问："
echo "动态URL: ${BACKEND_ADMIN_URL}/content-manager/collection-types/api::${content_type}.${content_type}"
```

### **CI/CD集成建议**
```bash
# 在CI管道中集成硬编码检查
stages:
  - hardcode-check
  - syntax-check  
  - build
  - test
  - deploy

hardcode-check:
  script:
    - ./scripts/tools/check-hardcode.sh
  allow_failure: false  # 硬编码检查失败必须阻止部署
```

---

## 📋 团队协作规范

### **代码审查清单**
- [ ] 运行硬编码检查工具
- [ ] 验证所有URL使用动态变量
- [ ] 检查文件行数不超过500行
- [ ] 确认语法正确无误
- [ ] 测试不同环境配置

### **新团队成员培训**
1. **必读文档**: `.cursor/rules/hardcode-prevention.mdc`
2. **工具使用**: `./scripts/tools/check-hardcode.sh`
3. **配置管理**: `deployment/configure-unified-env.sh`
4. **实践练习**: 修复一个硬编码问题

### **规则执行监督**
- **每周检查**: 运行硬编码检查工具
- **问题追踪**: 记录和分析硬编码问题
- **规则更新**: 发现新模式时更新规则

---

**版本**: v1.0  
**创建时间**: 2024年12月19日  
**适用项目**: AI变现之路  
**更新策略**: 发现新问题时立即更新